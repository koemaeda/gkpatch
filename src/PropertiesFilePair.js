const program = require('commander');
const chalk = require('chalk');
const fs = require('fs');
const path = require('path');
const jsDiff = require('diff');
const beautify = require('js-beautify').html;
const FilePair = require('./FilePair');
const PropertiesFile = require('./PropertiesFile');

module.exports = class PropertiesFilePair extends FilePair {

  constructor(paths) {
    super(paths);
  }

  async canonicalize() {
    const props = new PropertiesFile(this.fullLeftPath);
    await props.parse();
    this.save(props.canonicalize());
  }

  async compare() {
    let left, right;
    if (this.fullLeftPath) {
      left = new PropertiesFile(this.fullLeftPath);
      await left.parse();
    }
    if (this.fullRightPath) {
      right = new PropertiesFile(this.fullRightPath);
      await right.parse();
    }

    if (! this.fullLeftPath) {
      console.log(chalk.red(`Right only: ${this.relativePath}`));
      return;
    }
    else if (! this.fullRightPath) {
      console.log(chalk.green(`Left only: ${this.relativePath}`));
      return;
    }

    const diff = left.compare(right);
    if (diff.length === 0) {
      if (program.verbose)
        console.log(chalk.grey(`Identical: ${this.relativePath}`));
      return;
    }

    console.log(chalk.yellow(`Different: ${this.relativePath}`));

    // TODO - contents flag
    diff.forEach(d => {
      if (d.leftValue && d.rightValue) {
        console.log(chalk.red  (`  - ${d.key}=${d.leftValue}`));
        console.log(chalk.green(`  + ${d.key}=${d.rightValue}`));
      }
      else if (d.rightValue == undefined) {
        console.log(chalk.red  (`  - ${d.key}=${d.leftValue}`));
      }
      else if (d.leftValue == undefined) {
        console.log(chalk.green  (`  + ${d.key}=${d.rightValue}`));
      }
    });
  }

  async patch() {
    let left, right;
    if (this.fullLeftPath) {
      left = new PropertiesFile(this.fullLeftPath);
      await left.parse();
    }
    if (this.fullRightPath) {
      right = new PropertiesFile(this.fullRightPath);
      await right.parse();
    }

    if (! this.fullLeftPath) {
      if (program.verbose)
        console.log(chalk.grey(`  Right only: ${this.relativePath} -> ignored`));
      return;
    }
    else if (! this.fullRightPath) {
      if (program.verbose)
        console.log(chalk.green(`  Left only: ${this.relativePath} -> copy to overwrite`));
      this.copy(this.fullLeftPath, path.resolve(this.outputPath, 'overwrite', this.relativePath));
      return;
    }

    const diff = left.compare(right);
    if (diff.length === 0) {
      if (program.verbose)
        console.log(chalk.grey(`Identical: ${this.relativePath}`));
      return;
    }
    else if (diff.length > 100) {
      console.warn(chalk.yellow(`WARNING: More than 100 differences found in ${this.relativePath} (${diff.length} total).` +
        ' Moved to overwrite instead of patch.'));
      this.copy(this.fullLeftPath, path.resolve(this.outputPath, 'overwrite', this.relativePath));
      return;
    }
    else if (program.verbose)
      console.log(chalk.yellow(`  Different: ${this.relativePath} -> generate patch file`));

    const patchItems = diff.map(d => {
      const item = {
        name: d.key,
        value: d.rightValue
      };
      if (item.value && item.value.indexOf('${') !== -1)
        console.warn(chalk.yellow(`WARNING: Property ${item.name} contains placeholders.`));
      if (item.value == undefined)
        delete item.value;
      if (/[<>]/.test(item.value))
        item.value = `<![CDATA[${item.value}]]>`;

      if (d.leftValue && d.rightValue)
        item.operation = 'modify';
      else if (d.rightValue == undefined) {
        item.operation = 'comment';
      }
      else if (d.leftValue == undefined) {
        item.operation = 'add';
        item.after = d.key;
        while (item.after && !left.keyExists(item.after))
          item.after = right.getKeyBefore(item.after);
        if (! item.after) {
          item.before = d.key;
          while (item.before && !left.keyExists(item.before))
            item.before = right.getKeyAfter(item.before);
        }
      }
      return item;
    });
    if (program.verbose)
      console.log(`    ${patchItems.length} patch item generated`);

    const patchXml = beautify(
      `<!-- Generated by gkpatch on ${new Date().toLocaleString()} -->` +
      '<processor>' +
      patchItems.map(p =>
        `<${p.operation}>` +
        Object.keys(p).filter(key => /name|value|before|after/.test(key))
          .map(key => `<${key}>${p[key]}</${key}>`)
          .join('') +
        `</${p.operation}>`).join('') +
      '</processor>');

    const patchPath = path.resolve(this.outputPath, 'patch', this.relativePath + '.patch');
    this.save(patchXml, patchPath);
  }

}
